Token: separator	Lexeme: $$
<Rat15su> ::= $$ <Opt Function Definitions> $$ <Opt Declaration List> <Statement List> $$

Token: keyword	Lexeme: function
<Rat15su> ::= $$ <Opt Function Definitions> $$ <Opt Declaration List> <Statement List> $$

Token: keyword	Lexeme: function
<Function> ::= function <Identifier> (<Opt Parameters>) <Opt Declaration List> <Body>

Token: identifier	Lexeme: convert
<Function> ::= function <Identifier> (<Opt Parameters>) <Opt Declaration List> <Body>

Token: separator	Lexeme: (
<Function> ::= function <Identifier> (<Opt Parameters>) <Opt Declaration List> <Body>

Token: keyword	Lexeme: integer
<Qualifier> ::= integer

Token: identifier	Lexeme: fahr
<Parameter> ::= <Qualifier> <Identifier>

Token: separator	Lexeme: )
<Function> ::= function <Identifier> (<Opt Parameters>) <Opt Declaration List> <Body>

Token: separator	Lexeme: {
<Body> ::= { <Statement List> }

Token: keyword	Lexeme: return
<Return> ::= return <Expression>;

Token: integer	Lexeme: 5
<Primary> ::= <Integer>

Token: operator	Lexeme: *
<Term Prime> ::= * <Factor> <Term Prime> | <Empty>

Token: separator	Lexeme: (
<Primary> ::= (<Expression>)

Token: identifier	Lexeme: fahr
<Primary> ::= <Identifier>

Token: operator	Lexeme: -
<Expression Prime> ::= - <Term> <Expression Prime> | <Empty>

Token: integer	Lexeme: 32
<Primary> ::= <Integer>

Token: separator	Lexeme: )
<Primary> ::= (<Expression>)

Token: operator	Lexeme: /
<Term Prime> ::= / <Factor> <Term Prime> | <Empty>

Token: integer	Lexeme: 9
<Primary> ::= <Integer>

Token: separator	Lexeme: ;
<Return> ::= return <Expression>;

Token: separator	Lexeme: }
<Body> ::= { <Statement List> }

Token: keyword	Lexeme: integer
<Rat15su> ::= $$ <Opt Function Definitions> $$ <Opt Declaration List> <Statement List> $$

Token: keyword	Lexeme: integer
<Qualifier> ::= integer

Token: identifier	Lexeme: low
<IDs> ::= <Identifier>

Token: separator	Lexeme: ,
<IDs> ::= <Identifier>, <IDs>

Token: identifier	Lexeme: high
<IDs> ::= <Identifier>

Token: separator	Lexeme: ,
<IDs> ::= <Identifier>, <IDs>

Token: identifier	Lexeme: step
<IDs> ::= <Identifier>

Token: separator	Lexeme: ;
<Declaration List> ::= <Declaration>; | <Declaration>; <Declaration List>

Token: keyword	Lexeme: read
<Read> ::= read(<IDs>);

Token: separator	Lexeme: (
<Read> ::= read(<IDs>);

Token: identifier	Lexeme: low
<IDs> ::= <Identifier>

Token: separator	Lexeme: ,
<IDs> ::= <Identifier>, <IDs>

Token: identifier	Lexeme: high
<IDs> ::= <Identifier>

Token: separator	Lexeme: ,
<IDs> ::= <Identifier>, <IDs>

Token: identifier	Lexeme: step
<IDs> ::= <Identifier>

Token: separator	Lexeme: )
<Read> ::= read(<IDs>);

Token: separator	Lexeme: ;
<Read> ::= read(<IDs>);

Token: keyword	Lexeme: while
<While> ::= while(<Condition>) <Statement>

Token: separator	Lexeme: (
<While> ::= while(<Condition>) <Statement>

Token: identifier	Lexeme: low
<Primary> ::= <Identifier>

Token: operator	Lexeme: <
<Relop> ::= <

Token: identifier	Lexeme: high
<Primary> ::= <Identifier>

Token: separator	Lexeme: )
<While> ::= while(<Condition>) <Statement>

Token: separator	Lexeme: {
<Compound> ::= { <Statement List> }

Token: keyword	Lexeme: write
<Write> ::= write(<Expression>);

Token: separator	Lexeme: (
<Write> ::= write(<Expression>);

Token: identifier	Lexeme: low
<Primary> ::= <Identifier>

Token: separator	Lexeme: )
<Write> ::= write(<Expression>);

Token: separator	Lexeme: ;
<Write> ::= write(<Expression>);

Token: keyword	Lexeme: write
<Write> ::= write(<Expression>);

Token: separator	Lexeme: (
<Write> ::= write(<Expression>);

Token: identifier	Lexeme: convert
<Primary> ::= <Identifier>

Token: separator	Lexeme: (
<Primary> ::= <Identifier> (<IDs>)

Token: identifier	Lexeme: low
<IDs> ::= <Identifier>

Token: separator	Lexeme: )
<Primary> ::= <Identifier> (<IDs>)

Token: separator	Lexeme: )
<Write> ::= write(<Expression>);

Token: separator	Lexeme: ;
<Write> ::= write(<Expression>);

Token: identifier	Lexeme: low
<Assign> ::= <Identifier> = <Expression>;

Token: operator	Lexeme: =
<Assign> ::= <Identifier> = <Expression>;

Token: identifier	Lexeme: low
<Primary> ::= <Identifier>

Token: operator	Lexeme: +
<Expression Prime> ::= + <Term> <Expression Prime> | <Empty>

Token: identifier	Lexeme: step
<Primary> ::= <Identifier>

Token: separator	Lexeme: ;
<Assign> ::= <Identifier> = <Expression>;

Token: separator	Lexeme: }
<Compound> ::= { <Statement List> }

